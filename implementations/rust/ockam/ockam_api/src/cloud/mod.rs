use tracing::trace;

use minicbor::{Decode, Encode};
use ockam::{
    authenticated_storage::InMemoryStorage,
    identity::{Identity, IdentityVault, TrustEveryonePolicy},
    route,
};
use ockam_core::{self, Address, Route};
use ockam_node::Context;

use crate::auth::types::Attributes;
use crate::cloud::enroll::{auth0::*, enrollment_token::*, *};
use crate::cloud::invitation::{CreateInvitation, Invitation};
use crate::cloud::project::{CreateProject, Project};
use crate::cloud::space::{CreateSpace, Space};
#[cfg(feature = "tag")]
use crate::TypeTag;
use crate::{decode, is_ok, request};
use crate::{CowStr, Request};

pub mod enroll;
pub mod invitation;
pub mod project;
pub mod space;

/// A wrapper around a cloud request with extra fields.
#[derive(Encode, Decode, Debug)]
#[cfg_attr(test, derive(Clone))]
#[rustfmt::skip]
#[cbor(map)]
pub struct CloudRequestWrapper<'a, T> {
    #[cfg(feature = "tag")]
    #[n(0)] pub tag: TypeTag<8956240>,
    #[b(1)] pub req: T,
    #[b(2)] pub cloud_address: CowStr<'a>,
}

impl<'a, T> CloudRequestWrapper<'a, T> {
    pub fn new(req: T, cloud_node_address: Address) -> Self {
        Self {
            #[cfg(feature = "tag")]
            tag: TypeTag,
            req,
            cloud_address: cloud_node_address.to_string().into(),
        }
    }
}

/// A CloudRequestWrapper without an internal request.
pub type BareCloudRequestWrapper<'a> = CloudRequestWrapper<'a, ()>;

impl<'a> BareCloudRequestWrapper<'a> {
    pub fn bare(cloud_node_address: Address) -> Self {
        Self::new((), cloud_node_address)
    }
}

const TARGET: &str = "ockam_api::cloud::client";

pub struct MessagingClient {
    ctx: Context,

    /// Address of the secure channel local endpoint
    channel: Address,

    buf: Vec<u8>,
}

impl MessagingClient {
    pub async fn new<V: IdentityVault>(
        route: Route,
        identity: Identity<V>,
        ctx: &Context,
    ) -> ockam_core::Result<Self> {
        let ctx = ctx.new_detached(Address::random_local()).await?;

        // Create an AuthenticatedStorage to store info about Sender's known Identities.
        let storage = InMemoryStorage::new();

        // As Sender, connect to the Ockam Orchestrator secure channel listener, and perform an
        // Authenticated Key Exchange to establish an encrypted secure channel with its api
        // endpoint.
        // TODO: verify server' identity (pubkey hardcoded on ockam-command)
        let channel = identity
            .create_secure_channel(route.clone(), TrustEveryonePolicy, &storage)
            .await?;
        Ok(MessagingClient {
            ctx,
            channel,
            buf: Vec::new(),
        })
    }

    /// Executes an enrollment process to generate a new set of access tokens using the auth0 flow.
    pub async fn enroll_auth0<S>(&mut self, auth0_service: S) -> ockam_core::Result<()>
    where
        S: Auth0TokenProvider,
    {
        trace!(target: TARGET, "executing auth0 flow");
        let token = {
            let token = auth0_service.token().await?;
            AuthenticateToken::Auth0(AuthenticateAuth0Token::new(token))
        };
        self.authenticate_token(token).await?;
        Ok(())
    }

    /// Generates a token that will be associated to the passed attributes.
    pub async fn generate_enrollment_token(
        &mut self,
        attributes: Attributes<'_>,
    ) -> ockam_core::Result<EnrollmentToken<'static>> {
        let label = "enrollment_token_generator";
        trace!(target: TARGET, "generating tokens");

        let body = RequestEnrollmentToken::new(attributes);
        let req = Request::post("v0/").body(body);
        let route = self.api_service_route("enrollment_token_authenticator");
        // TODO: change `schema` to `attributes` after secure channels are enabled (identifier arg is not used)
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        decode(label, None, &self.buf)
    }

    /// Authenticates a token generated by `generate_enrollment_token`.
    pub async fn authenticate_enrollment_token(
        &mut self,
        token: EnrollmentToken<'_>,
    ) -> ockam_core::Result<()> {
        trace!(target: TARGET, "authenticating token");
        let token = AuthenticateToken::EnrollmentToken(AuthenticateEnrollmentToken::new(token));
        self.authenticate_token(token).await?;
        Ok(())
    }

    async fn authenticate_token(&mut self, body: AuthenticateToken<'_>) -> ockam_core::Result<()> {
        // TODO: add AuthenticateAuth0Token to schema.cddl and use it here
        let schema = None;
        let label;
        match body {
            AuthenticateToken::Auth0(body) => {
                label = "auth0_authenticator";
                let route = self.api_service_route(label);
                let req = Request::post("v0/enroll").body(body);
                self.buf = request(&mut self.ctx, label, schema, route, req).await?;
            }
            AuthenticateToken::EnrollmentToken(body) => {
                label = "enrollment_token_authenticator";
                let route = self.api_service_route(label);
                let req = Request::post("v0/enroll").body(body);
                self.buf = request(&mut self.ctx, label, schema, route, req).await?;
            }
        };
        is_ok(label, &self.buf)
    }

    pub async fn create_invitation(
        &mut self,
        body: CreateInvitation<'_>,
    ) -> ockam_core::Result<Invitation<'_>> {
        let label = "create_invitation";
        trace!(target:  TARGET, space = ?body.space_id, "creating invitation");

        let route = self.api_service_route("invitations");
        let req = Request::post("v0/").body(body);
        self.buf = request(&mut self.ctx, label, "create_invitation", route, req).await?;
        decode(label, "invitation", &self.buf)
    }

    pub async fn list_invitations(&mut self) -> ockam_core::Result<Vec<Invitation<'_>>> {
        let label = "list_invitations";
        trace!(target: TARGET, "listing invitations");

        let route = self.api_service_route("invitations");
        let req = Request::get("v0/");
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        decode(label, "invitations", &self.buf)
    }

    pub async fn accept_invitations(&mut self, invitation_id: &str) -> ockam_core::Result<()> {
        let label = "accept_invitation";
        trace!(target: TARGET, "accept invitation");

        let route = self.api_service_route("invitations");
        let req = Request::put(format!("v0/{invitation_id}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        is_ok(label, &self.buf)
    }

    pub async fn reject_invitations(&mut self, invitation_id: &str) -> ockam_core::Result<()> {
        let label = "reject_invitation";
        trace!(target: TARGET, "reject invitation");

        let route = self.api_service_route("invitations");
        let req = Request::delete(format!("v0/{invitation_id}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        is_ok(label, &self.buf)
    }

    pub async fn create_space(&mut self, body: CreateSpace<'_>) -> ockam_core::Result<Space<'_>> {
        let label = "create_space";
        trace!(target: TARGET, space = %body.name, "creating space");

        let route = self.api_service_route("spaces");
        let req = Request::post("v0/").body(body);
        self.buf = request(&mut self.ctx, label, "create_space", route, req).await?;
        decode(label, "space", &self.buf)
    }

    pub async fn list_spaces(&mut self) -> ockam_core::Result<Vec<Space<'_>>> {
        let label = "list_spaces";
        trace!(target: TARGET, "listing spaces");

        let route = self.api_service_route("spaces");
        let req = Request::get("v0/");
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        decode(label, "spaces", &self.buf)
    }

    pub async fn get_space(&'_ mut self, space_id: &str) -> ockam_core::Result<Space<'_>> {
        let label = "get_space";
        trace!(target: TARGET, space = %space_id, space = %space_id, "getting space");

        let route = self.api_service_route("spaces");
        let req = Request::get(format!("v0/{space_id}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        decode(label, "space", &self.buf)
    }

    pub async fn get_space_by_name(
        &'_ mut self,
        space_name: &str,
    ) -> ockam_core::Result<Space<'_>> {
        let label = "get_space_by_name";
        trace!(target: TARGET, space = %space_name, "getting space");

        let route = self.api_service_route("spaces");
        let req = Request::get(format!("v0/name/{space_name}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        decode(label, "space", &self.buf)
    }

    pub async fn delete_space(&mut self, space_id: &str) -> ockam_core::Result<()> {
        let label = "delete_space";
        trace!(target: TARGET, space = %space_id, "deleting space");

        let route = self.api_service_route("spaces");
        let req = Request::delete(format!("v0/{space_id}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        is_ok(label, &self.buf)
    }

    pub async fn create_project(
        &mut self,
        space_id: &str,
        body: CreateProject<'_>,
    ) -> ockam_core::Result<Project<'_>> {
        let label = "create_project";
        trace!(target: TARGET, space = %space_id, project = %body.name, "creating project");

        let route = self.api_service_route("projects");
        let req = Request::post(format!("v0/{space_id}")).body(body);
        self.buf = request(&mut self.ctx, label, "create_project", route, req).await?;
        decode(label, "project", &self.buf)
    }

    pub async fn list_projects(&mut self, space_id: &str) -> ockam_core::Result<Vec<Project<'_>>> {
        let label = "list_projects";
        trace!(target: TARGET, space = %space_id, "listing projects");

        let route = self.api_service_route("projects");
        let req = Request::get(format!("v0/{space_id}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        decode(label, "projects", &self.buf)
    }

    pub async fn get_project(
        &'_ mut self,
        space_id: &str,
        project_id: &str,
    ) -> ockam_core::Result<Project<'_>> {
        let label = "get_project";
        trace!(target: TARGET, space = %space_id, project = %project_id, "getting project");

        let route = self.api_service_route("projects");
        let req = Request::get(format!("v0/{space_id}/{project_id}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        decode(label, "project", &self.buf)
    }

    pub async fn get_project_by_name(
        &'_ mut self,
        space_id: &str,
        project_name: &str,
    ) -> ockam_core::Result<Project<'_>> {
        let label = "get_project_by_name";
        trace!(target: TARGET, space = %space_id, project = %project_name, "getting project");

        let route = self.api_service_route("projects");
        let req = Request::get(format!("v0/{space_id}/name/{project_name}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        decode(label, "project", &self.buf)
    }

    pub async fn delete_project(
        &mut self,
        space_id: &str,
        project_id: &str,
    ) -> ockam_core::Result<()> {
        let label = "delete_project";
        trace!(target: TARGET, space = %space_id, project = %project_id, "deleting project");

        let route = self.api_service_route("projects");
        let req = Request::delete(format!("v0/{space_id}/{project_id}"));
        self.buf = request(&mut self.ctx, label, None, route, req).await?;
        is_ok(label, &self.buf)
    }

    fn api_service_route(&self, api_service: &str) -> Route {
        route![self.channel.clone(), api_service]
    }
}
