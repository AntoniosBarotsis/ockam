use minicbor::{Decoder, Encode};
use tracing::{trace, warn};

use ockam::{
    authenticated_storage::InMemoryStorage,
    identity::{Identity, IdentityVault, TrustEveryonePolicy},
    route,
};
use ockam_core::errcode::{Kind, Origin};
use ockam_core::{self, Address, Route};
use ockam_node::Context;

use crate::auth::types::Attributes;
use crate::cloud::enroll::{auth0::*, enrollment_token::*, *};
use crate::cloud::invitation::{CreateInvitation, Invitation};
use crate::cloud::project::{CreateProject, Project};
use crate::cloud::space::{CreateSpace, Space};
use crate::{Error, Response};
use crate::{Request, RequestBuilder, Status};

pub mod enroll;
pub mod invitation;
pub mod project;
pub mod space;

pub struct MessagingClient {
    ctx: Context,

    /// Address of the secure channel local endpoint
    channel: Address,

    buf: Vec<u8>,
}

impl MessagingClient {
    pub async fn new<V: IdentityVault>(
        route: Route,
        identity: Identity<V>,
        ctx: &Context,
    ) -> ockam_core::Result<Self> {
        let ctx = ctx.new_detached(Address::random_local()).await?;

        // Create an AuthenticatedStorage to store info about Sender's known Identities.
        let storage = InMemoryStorage::new();

        // As Sender, connect to the Ockam Orchestrator secure channel listener, and perform an
        // Authenticated Key Exchange to establish an encrypted secure channel with its api
        // endpoint.
        // TODO: verify server' identity (pubkey hardcoded on ockam-command)
        let channel = identity
            .create_secure_channel(route.clone(), TrustEveryonePolicy, &storage)
            .await?;
        Ok(MessagingClient {
            ctx,
            channel,
            buf: Vec::new(),
        })
    }

    /// Executes an enrollment process to generate a new set of access tokens using the auth0 flow.
    pub async fn enroll_auth0<'a, S>(&mut self, mut auth0_service: S) -> ockam_core::Result<()>
    where
        S: Auth0TokenProvider<'a, T = Auth0Token<'a>>,
    {
        let target = "ockam_api::cloud::enroll_auth0";
        trace!(target = %target, "executing auth0 flow");

        let token = {
            let token = auth0_service.token().await?;
            AuthenticateToken::Auth0(AuthenticateAuth0Token::new(token))
        };
        self.authenticate_token(token).await?;
        Ok(())
    }

    /// Generates a token that will be associated to the passed attributes.
    pub async fn generate_enrollment_token(
        &mut self,
        attributes: Attributes<'_>,
    ) -> ockam_core::Result<EnrollmentToken<'static>> {
        let target = "ockam_api::cloud::generate_enrollment_token";
        let label = "generate_enrollment_token";
        trace!(target = %target, "generating tokens");

        let body = RequestEnrollmentToken::new(attributes);
        let req = Request::post("v0/").body(body);
        self.buf = self
            .request(target, label, "enrollment_token_authenticator", &req)
            .await?;

        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    /// Authenticates a token generated by `generate_enrollment_token`.
    pub async fn authenticate_enrollment_token(
        &mut self,
        token: EnrollmentToken<'_>,
    ) -> ockam_core::Result<()> {
        let target = "ockam_api::cloud::authenticate_enrollment_token";
        trace!(target = %target, "authenticating token");

        let token = AuthenticateToken::EnrollmentToken(AuthenticateEnrollmentToken::new(token));
        self.authenticate_token(token).await?;
        Ok(())
    }

    async fn authenticate_token(&mut self, body: AuthenticateToken<'_>) -> ockam_core::Result<()> {
        let target = "ockam_api::cloud::enroll::authenticate_token";
        let label;

        match body {
            AuthenticateToken::Auth0(body) => {
                label = "authenticate_token__auth0";
                let req = Request::post("v0/enroll").body(body);
                self.buf = self
                    .request(target, label, "auth0_authenticator", &req)
                    .await?;
            }
            AuthenticateToken::EnrollmentToken(body) => {
                label = "authenticate_token__enrollment_token";
                let req = Request::post("v0/enroll").body(body);
                self.buf = self
                    .request(target, label, "enrollment_token_authenticator", &req)
                    .await?;
            }
        };

        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            Ok(())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn create_invitation(
        &mut self,
        body: CreateInvitation<'_>,
    ) -> ockam_core::Result<Invitation<'_>> {
        let target = "ockam_api::cloud::create_invitation";
        let label = "create_invitation";
        trace!(target = target, space = ?body.space_id, "creating invitation");

        let req = Request::post("v0/").body(body);
        self.buf = self.request(target, label, "invitations", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn list_invitations(&mut self) -> ockam_core::Result<Vec<Invitation<'_>>> {
        let target = "ockam_api::cloud::list_invitations";
        let label = "list_invitations";
        trace!(target = %target, "listing invitations");

        let req = Request::get("v0/");
        self.buf = self.request(target, label, "invitations", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn accept_invitations(&mut self, invitation_id: &str) -> ockam_core::Result<()> {
        let target = "ockam_api::cloud::accept_invitations";
        let label = "accept_invitation";
        trace!(target = %target, "accept invitation");

        let req = Request::put(format!("v0/{}", invitation_id));
        self.buf = self.request(target, label, "invitations", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            Ok(())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn reject_invitations(&mut self, invitation_id: &str) -> ockam_core::Result<()> {
        let target = "ockam_api::cloud::reject_invitations";
        let label = "reject_invitation";
        trace!(target = %target, "reject invitation");

        let req = Request::delete(format!("v0/{}", invitation_id));
        self.buf = self.request(target, label, "invitations", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            Ok(())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn create_space(&mut self, body: CreateSpace<'_>) -> ockam_core::Result<Space<'_>> {
        let target = "ockam_api::cloud::create_space";
        let label = "create_space";
        trace!(target = %target, space = %body.name, "creating space");

        let req = Request::post("v0/").body(body);
        self.buf = self.request(target, label, "spaces", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn list_spaces(&mut self) -> ockam_core::Result<Vec<Space<'_>>> {
        let target = "ockam_api::cloud::list_spaces";
        let label = "list_spaces";
        trace!(target = %target, "listing spaces");

        let req = Request::get("v0/");
        self.buf = self.request(target, label, "spaces", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn get_space(&mut self, space_id: &str) -> ockam_core::Result<Space<'_>> {
        let target = "ockam_api::cloud::get_space";
        let label = "get_space";
        trace!(target = %target, space = %space_id, space = %space_id, "getting space");

        let req = Request::get(format!("v0/{space_id}"));
        self.buf = self.request(target, label, "spaces", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn get_space_by_name(&mut self, space_name: &str) -> ockam_core::Result<Space<'_>> {
        let target = "ockam_api::cloud::get_space_by_name";
        let label = "get_space_by_name";
        trace!(target = %target, space = %space_name, "getting space");

        let req = Request::get(format!("v0/name/{space_name}"));
        self.buf = self.request(target, label, "spaces", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn delete_space(&mut self, space_id: &str) -> ockam_core::Result<()> {
        let target = "ockam_api::cloud::delete_space";
        let label = "delete_space";
        trace!(target = %target, space = %space_id, "deleting space");

        let req = Request::delete(format!("v0/{space_id}"));
        self.buf = self.request(target, label, "spaces", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            Ok(())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn create_project(
        &mut self,
        space_id: &str,
        body: CreateProject<'_>,
    ) -> ockam_core::Result<Project<'_>> {
        let target = "ockam_api::cloud::create_project";
        let label = "create_project";
        trace!(target = %target, space = %space_id, project = %body.name, "creating project");

        let req = Request::post(format!("v0/{space_id}")).body(body);
        self.buf = self.request(target, label, "projects", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn list_projects(&mut self, space_id: &str) -> ockam_core::Result<Vec<Project<'_>>> {
        let target = "ockam_api::cloud::list_projects";
        let label = "list_projects";
        trace!(target = %target, space = %space_id, "listing projects");

        let req = Request::get(format!("v0/{space_id}"));
        self.buf = self.request(target, label, "projects", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn get_project(
        &mut self,
        space_id: &str,
        project_id: &str,
    ) -> ockam_core::Result<Project<'_>> {
        let target = "ockam_api::cloud::get_project";
        let label = "get_project";
        trace!(target = %target, space = %space_id, project = %project_id, "getting project");

        let req = Request::get(format!("v0/{space_id}/{project_id}"));
        self.buf = self.request(target, label, "projects", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn get_project_by_name(
        &mut self,
        space_id: &str,
        project_name: &str,
    ) -> ockam_core::Result<Project<'_>> {
        let target = "ockam_api::cloud::get_project_by_name";
        let label = "get_project_by_name";
        trace!(target = %target, space = %space_id, project = %project_name, "getting project");

        let req = Request::get(format!("v0/{space_id}/name/{project_name}"));
        self.buf = self.request(target, label, "projects", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            d.decode().map_err(|e| e.into())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    pub async fn delete_project(
        &mut self,
        space_id: &str,
        project_id: &str,
    ) -> ockam_core::Result<()> {
        let target = "ockam_api::cloud::delete_project";
        let label = "delete_project";
        trace!(target = %target, space = %space_id, project = %project_id, "deleting project");

        let req = Request::delete(format!("v0/{space_id}/{project_id}"));
        self.buf = self.request(target, label, "projects", &req).await?;
        let mut d = Decoder::new(&self.buf);
        let res = response(target, label, &mut d)?;
        if res.status() == Some(Status::Ok) {
            Ok(())
        } else {
            Err(error(target, label, &res, &mut d))
        }
    }

    /// Encode request header and body (if any), send the package to the server and returns its response.
    async fn request<T>(
        &mut self,
        target: &str,
        label: &str,
        service_api: &str,
        req: &RequestBuilder<'_, T>,
    ) -> ockam_core::Result<Vec<u8>>
    where
        T: Encode<()>,
    {
        let mut buf = Vec::new();
        req.encode(&mut buf)?;
        trace!(target = %target, label = %label, id = %req.header().id(), worker = %service_api, "-> req");
        let route = route![self.channel.clone(), service_api];
        let vec: Vec<u8> = self.ctx.send_and_receive(route, buf).await?;
        Ok(vec)
    }
}

/// Decode and log response header.
pub(crate) fn response(
    target: &str,
    label: &str,
    dec: &mut Decoder<'_>,
) -> ockam_core::Result<Response> {
    let res: Response = dec.decode()?;
    trace! {
        target = target,
        label  = %label,
        id     = %res.id(),
        re     = %res.re(),
        status = ?res.status(),
        body   = %res.has_body(),
        "<- res"
    }
    Ok(res)
}

/// Decode, log and mape response error to ockam_core error.
pub(crate) fn error(
    target: &str,
    label: &str,
    res: &Response,
    dec: &mut Decoder<'_>,
) -> ockam_core::Error {
    if res.has_body() {
        let err = match dec.decode::<Error>() {
            Ok(e) => e,
            Err(e) => return e.into(),
        };
        warn! {
            target = target,
            label  = %label,
            id     = %res.id(),
            re     = %res.re(),
            status = ?res.status(),
            error  = ?err.message(),
            "<- err"
        }
        let msg = err.message().unwrap_or(label);
        ockam_core::Error::new(Origin::Application, Kind::Protocol, msg)
    } else {
        ockam_core::Error::new(Origin::Application, Kind::Protocol, label)
    }
}
